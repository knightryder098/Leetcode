//character count 
#include <stdio.h>
#include <string.h>
int main()
{
	printf("Character Count\n");
	int x[100], y[30], i = 0, j = 0, count, num, n, total = 0;
	printf("enter # of frames :");
	scanf("%d", &num);
	for (int k = 0; k < num; k++)
	{
		printf("Enter the frame length: ");
		scanf("%d", &n);
		total += n + 1;
		printf("Enter the input frame: ");
		for (int a = 0; a < n; a++)
		{
			scanf("%d", &y[a]);
		}
		x[i++] = n + 1;
		for (int a = 0; a < n; a++)
		{
			x[i] = y[a];
			i++;
		}
		printf("\n");
	}
	printf("\nAfter Stuffing\n");
	for (int k = 0; k < total; k++)
	{
		printf("%d", x[k]);
	}
	printf("\n");
	return 0;
}


//hamming
#include <bits/stdc++.h>
using namespace std;

bool rbit(int index,int arr[], int size){
    bool ans=0;
    for(int i=index;i<=size;i=i+2*index){
        for(int j=0;j<index && i+j<=size;j++){
            ans ^= arr[i+j];
        }
    }
    return ans;
}

int main() {
	cout<<"Hamming Code\n\n";
	cout<<"-----Sender-----\n\n";
	cout<<"Enter size of Msg : ";
	int m;
	cin>>m;
	
	int r=1;
	while(m+1+r>pow(2,r)){
	    r++;
	}
	cout<<r<<endl;
	cout<<"Enter msg (space seperated) : ";
	
	int size = m+r;
	int data[size+1];
	//stored in reverse order
	//0th index is blank
	int k=r-1;
	for(int i=size;i>0;i--){
	    if(i == pow(2,k)){
	        data[i] = 0;
	        k--;
	        continue;
	    }
	    cin>>data[i];
	}
	for(int i=0;i<r;i++){
	    data[(int)pow(2,i)] = rbit(pow(2,i),data,size);
	}
	
	//print the msg
	for(int i = size;i>0;i--)
	    cout<<data[i]<<" ";
	
	cout<<"\n\n-----Receiver-----\n\n";
	cout<<"Enter size of Msg : ";
	int n;
	cin>>n;
	int msg[n+1];
	cout<<"Enter msg (space seperated) :";
	for(int i = n;i>0;i--){
		cin >> msg[i];
	}
	int rb=1;
	while(pow(2,rb)<n){
		rb++;
	}
	int err[rb+1];	//0th blank
	for(int i=0;i<rb;i++){
	    err[i+1] = rbit(pow(2,i),msg,n);
	}
	int error=0;
	for(int i=1;i<=rb;i++){
		error += pow(2,i-1)*err[i];
	}
	if(error == 0)	cout<<"Noiseless Data"<<endl;
	else{
		cout<<"Error at "<<error<<" position"<<endl;;
		msg[error] = 1 - msg[error];
		cout<<"corrected data : ";
		for(int i = n;i>0;i--)
	    	cout<<msg[i]<<" ";
	}
	cout<<endl;
	return 0;
}


//

//port scanner

#include <netinet/in.h>
#include <stdio.h>
#include <sys/socket.h>
#include <errno.h>
#include <netdb.h>
#include <string.h>
#include <stdlib.h>
#include <arpa/inet.h>
#include <ctype.h>
#include <unistd.h>

int main()
{
    int sockfd;
    struct sockaddr_in addr;
    socklen_t len = sizeof(addr);
    int port;

    for (port = 1; port <= 65535; port++)
    {
        sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd < 0)
        {
            perror("socket");
            exit(1);
        }

        addr.sin_family = AF_INET;
        addr.sin_addr.s_addr = htonl(INADDR_ANY);
        addr.sin_port = htons(port);

        if (bind(sockfd, (struct sockaddr *)&addr, sizeof(addr)) != 0)
        {
            printf("Port %d is open.\n", port);
        }
    
        close(sockfd);
    }

    return 0;
}


//CRC

#include <iostream>
#include <bits/stdc++.h>
using namespace std;

int main() {
	cout<<"CRC\n\n";
	cout<<"----------Sender----------\n\n";
	vector<int> key;
	vector<int> data;
    int num;
    cout<<"enter length of key :";
    cin>>num;
    cout<<"enter key(space seperated) : ";
	while(num--){
	    int val;
	    cin>>val;
	    key.push_back(val);
	}
	cout<<"enter length of msg :";
    cin>>num;
	cout<<"enter msg(space seperated) : ";
	while(num--){
	    int val;
	    cin>>val;
	    data.push_back(val);
	}
	
	//append n-1 zeroes to data
	for(int i=1;i<(int)key.size();i++){
	    data.push_back(0);                                                                                                      
	}
	vector<int> msg(data);
	while(data.size()>=key.size()){
    	int flag=0;
    	
	    //binary division
	    for(int i=0,j=0;i<(int)key.size();i++,j++){
	        data[j] = data[j]^key[i];
	        //removing trailing zeores
            if(data[j]==0 && flag==0){
	            data.erase(data.begin());
	            j--;
	        }
	        else if(data[j]==1){
	            flag=1;
	        }
	    }
	}
	cout<<endl;
	cout<<"message to be transmitted : ";
	//adding remainder to msg
	for(int i=(int)data.size()-1,j=(int)msg.size()-1;i>=0;i--,j--){
	    msg[j] |= data[i];
	}
	for(auto &ele : msg)    cout<<ele<<" ";
	
	cout<<"\n\n----------Receiver----------\n\n";
	cout<<"enter length of msg : ";
	cin>>num;
	cout<<"Enter msg(space seperated) : ";
	vector<int> rec;
	while(num--){
	    int val;
	    cin>>val;
	    rec.push_back(val);
	}
	while(rec.size()>=key.size()){
    	int flag=0;
    	
	    //binary division
	    for(int i=0,j=0;i<(int)key.size();i++,j++){
	        rec[j] = rec[j]^key[i];
	        //removing trailing zeores
            if(rec[j]==0 && flag==0){
	            rec.erase(rec.begin());
	            j--;
	        }
	        else if(rec[j]==1){
	            flag=1;
	        }
	    }
	}
	
	if(!rec.size())    cout<<"\nNoiseless data is received";
	else    cout<<"\nData is corrupted";
	return 0;
}


//checksum
// C++ implementation of the above approach
#include <bits/stdc++.h>
using namespace std;

// Function to find the One's complement
// of the given binary string
string Ones_complement(string data)
{
	for (int i = 0; i < data.length(); i++) {
		if (data[i] == '0')
			data[i] = '1';
		else
			data[i] = '0';
	}

	return data;
}

// Function to return the checksum value of
// the given string when divided in K size blocks
string checkSum(string data, int block_size)
{
	// Check data size is divisible by block_size
	// Otherwise add '0' front of the data
	int n = data.length();
	if (n % block_size != 0) {
		int pad_size = block_size - (n % block_size);
		for (int i = 0; i < pad_size; i++) {
			data = '0' + data;
		}
	}

	// Binary addition of all blocks with carry
	string result = "";

	// First block of data stored in result variable
	for (int i = 0; i < block_size; i++) {
		result += data[i];
	}

	// Loop to calculate the block
	// wise addition of data
	for (int i = block_size; i < n; i += block_size) {

		// Stores the data of the next block
		string next_block = "";

		for (int j = i; j < i + block_size; j++) {
			next_block += data[j];
		}

		// Stores the binary addition of two blocks
		string additions = "";
		int sum = 0, carry = 0;

		// Loop to calculate the binary addition of
		// the current two blocls of k size
		for (int k = block_size - 1; k >= 0; k--) {
			sum += (next_block[k] - '0')
				+ (result[k] - '0');
			carry = sum / 2;
			if (sum == 0) {
				additions = '0' + additions;
				sum = carry;
			}
			else if (sum == 1) {
				additions = '1' + additions;
				sum = carry;
			}
			else if (sum == 2) {
				additions = '0' + additions;
				sum = carry;
			}
			else {
				additions = '1' + additions;
				sum = carry;
			}
		}

		// After binary add of two blocks with carry,
		// if carry is 1 then apply binary addition
		string final = "";

		if (carry == 1) {
			for (int l = additions.length() - 1; l >= 0;
				l--) {
				if (carry == 0) {
					final = additions[l] + final;
				}
				else if (((additions[l] - '0') + carry) % 2
						== 0) {
					final = "0" + final;
					carry = 1;
				}
				else {
					final = "1" + final;
					carry = 0;
				}
			}

			result = final;
		}
		else {
			result = additions;
		}
	}

	// Return One's complements of result value
	// which represents the required checksum value
	return Ones_complement(result);
}

// Function to check if the received message
// is same as the senders message
bool checker(string sent_message,
			string rec_message,
			int block_size)
{

	// Checksum Value of the senders message
	string sender_checksum
		= checkSum(sent_message, block_size);

	// Checksum value for the receivers message
	string receiver_checksum = checkSum(
		rec_message + sender_checksum, block_size);

	// If receivers checksum value is 0
	if (count(receiver_checksum.begin(),
			receiver_checksum.end(), '0')
		== block_size) {
		return true;
	}
	else {
		return false;
	}
}

// Driver Code
int main()
{
	string sent_message
		= "10000101011000111001010011101101";
	string recv_message
		= "10000101011000111001010011101101";
	int block_size = 8;

	if (checker(sent_message,
				recv_message,
				block_size)) {
		cout << "No Error";
	}
	else {
		cout << "Error";
	}

	return 0;
}

//gobackn

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <math.h>

#define WINDOW_SIZE 4
#define TIMEOUT 4
#define PACKET_SIZE 20
#define NUM_PACKETS 15

struct packet
{
  int seq_no;
  char data[PACKET_SIZE];
};

int main()
{
  struct packet packets[NUM_PACKETS];
  int i, j, k;
  srand(time(NULL));
  for (i = 0; i < NUM_PACKETS; i++)
  {
    packets[i].seq_no = i;
    for (j = 0; j < PACKET_SIZE; j++)
    {
      packets[i].data[j] = (char)(rand() % 26 + 'a');
    }
  }

  int window_start = 0;
  int window_end = WINDOW_SIZE - 1;
  int expected_ack = 0;
  int num_acks = 0;
  int timeout_count = 0;

  while (num_acks < NUM_PACKETS)
  {
    // Send packets in current window
    for (i = window_start; i <= window_end && i < NUM_PACKETS; i++)
    {
      printf("Sending packet with sequence number %d\n", packets[i].seq_no);
    }

    // Simulate sending packets
    for (i = window_start; i <= window_end && i < NUM_PACKETS; i++)
    {
      if (rand() % 10 > 1)
      { // packet not lost
        printf("Packet with sequence number %d sent successfully\n", packets[i].seq_no);
      }
      else
      { // packet lost
        printf("Packet with sequence number %d lost\n", packets[i].seq_no);
      }
    }

    // Receive acks
    for (i = window_start; i <= window_end && i < NUM_PACKETS; i++)
    {
      if (rand() % 10 > 1)
      { // ack not lost
        if (packets[i].seq_no == expected_ack)
        {
          printf("Received ack for packet with sequence number %d\n", packets[i].seq_no);
          num_acks++;
          expected_ack++;
          timeout_count = 0;
        }
        else
        {
          printf("Received out-of-order ack for packet with sequence number %d\n", packets[i].seq_no);
        }
      }
      else
      { // ack lost
        printf("Ack for packet with sequence number %d lost\n", packets[i].seq_no);
      }
    }

    // Update window
    if (expected_ack <= NUM_PACKETS - WINDOW_SIZE)
    {
      if (num_acks == window_end - window_start + 1)
      {
        window_start += num_acks;
        window_end += num_acks;
      }
    }
    else
    {
      if (num_acks == NUM_PACKETS - expected_ack)
      {
        window_end = NUM_PACKETS - 1;
        window_start = window_end - (WINDOW_SIZE - 1);
      }
    }

    // Timeout
    if (timeout_count >= TIMEOUT)
    {
      printf("Timeout occurred, resending packets in window\n");
      timeout_count = 0;
    }
    else
    {
      timeout_count++;
    }
  }

  printf("All packets successfully transmitted and acknowledged\n");

  return 0;
}


//
